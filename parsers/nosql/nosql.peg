{
package nosql

import "github.com/pikami/cosmium/parsers"

func makeSelectStmt(columns, table, whereClause interface{}, count interface{}, orderList interface{}) (parsers.SelectStmt, error) {
	selectStmt := parsers.SelectStmt{
		SelectItems: columns.([]parsers.SelectItem),
		Table:       table.(parsers.Table),
	}

	if filters, ok := whereClause.(parsers.ComparisonExpression); ok {
		selectStmt.Filters = filters
	} else if filters, ok := whereClause.(parsers.LogicalExpression); ok {
		selectStmt.Filters = filters
	} else if filters, ok := whereClause.(parsers.Constant); ok {
		selectStmt.Filters = filters
	} else if filters, ok := whereClause.(parsers.SelectItem); ok {
		selectStmt.Filters = filters
	}

	if n, ok := count.(int); ok {
		selectStmt.Count = n
	}

    if orderExpressions, ok := orderList.([]parsers.OrderExpression); ok {
        selectStmt.OrderExpressions = orderExpressions
    }

	return selectStmt, nil
}

func makeSelectItem(name interface{}, path interface{}, selectItemType parsers.SelectItemType) (parsers.SelectItem, error) {
	ps := path.([]interface{})

	paths := make([]string, 1)
    paths[0] = name.(string)
	for _, p := range ps {
        paths = append(paths, p.(string))
	}

	return parsers.SelectItem{Path: paths, Type: selectItemType}, nil
}

func makeColumnList(column interface{}, other_columns interface{}) ([]parsers.SelectItem, error) {
    collsAsArray := other_columns.([]interface{})
	columnList := make([]parsers.SelectItem, len(collsAsArray) + 1)
	columnList[0] = column.(parsers.SelectItem)

	for i, v := range collsAsArray {
        if col, ok := v.(parsers.SelectItem); ok {
			columnList[i+1] = col
        }
    }

	return columnList, nil
}

func makeSelectArray(columns interface{}) (parsers.SelectItem, error) {
	return parsers.SelectItem{
		SelectItems: columns.([]parsers.SelectItem),
		Type:        parsers.SelectItemTypeArray,
	}, nil
}

func makeSelectObject(field interface{}, other_fields interface{}) (parsers.SelectItem, error) {
    fieldsAsArray := other_fields.([]interface{})
	fieldsList := make([]parsers.SelectItem, len(fieldsAsArray)+1)
	fieldsList[0] = field.(parsers.SelectItem)

	for i, v := range fieldsAsArray {
		if col, ok := v.(parsers.SelectItem); ok {
			fieldsList[i+1] = col
		}
	}

	return parsers.SelectItem{
		SelectItems: fieldsList,
		Type:        parsers.SelectItemTypeObject,
	}, nil
}

func makeOrderByClause(ex1 interface{}, others interface{}) ([]parsers.OrderExpression, error) {
    othersArray := others.([]interface{})
	orderList := make([]parsers.OrderExpression, len(othersArray)+1)
	orderList[0] = ex1.(parsers.OrderExpression)

	for i, v := range othersArray {
		if col, ok := v.(parsers.OrderExpression); ok {
			orderList[i+1] = col
		}
	}

	return orderList, nil
}

func makeOrderExpression(field interface{}, order interface{}) (parsers.OrderExpression, error) {
    value := parsers.OrderExpression{
        SelectItem: field.(parsers.SelectItem),
        Direction: parsers.OrderDirectionAsc,
    }

    if orderValue, ok := order.(parsers.OrderDirection); ok {
		value.Direction = orderValue
	}

    return value, nil
}

func joinStrings(array []interface{}) string {
    var stringsArray []string
    for _, elem := range array {
        str, ok := elem.(string)
        if !ok {
            continue
        }
        stringsArray = append(stringsArray, str)
    }
    
    return strings.Join(stringsArray, "")
}

func combineExpressions(ex1 interface{}, exs interface{}, operation parsers.LogicalExpressionType) (interface{}, error) {
    if exs == nil || len(exs.([]interface{})) < 1 {
		return ex1, nil
	}

	return parsers.LogicalExpression{
		Expressions: append([]interface{}{ex1}, exs.([]interface{})...),
		Operation:   operation,
	}, nil
}

}

Input <- selectStmt:SelectStmt {
    return selectStmt, nil
}

SelectStmt <- Select ws topClause:TopClause? ws columns:Selection ws
    From ws table:TableName ws
    whereClause:(ws Where ws condition:Condition { return condition, nil })?
    orderByClause:OrderByClause? {
    return makeSelectStmt(columns, table, whereClause, topClause, orderByClause)
}

TopClause <- Top ws count:Integer {
    return count, nil
}

Selection <- SelectValueSpec / ColumnList / SelectAsterisk

SelectAsterisk <- "*" {
    selectItem, _ := makeSelectItem("c", make([]interface{}, 0), parsers.SelectItemTypeField)
	selectItem.IsTopLevel = true
    return makeColumnList(selectItem, make([]interface{}, 0))
}

ColumnList <- column:SelectItem other_columns:(ws "," ws coll:SelectItem {return coll, nil })* {
    return makeColumnList(column, other_columns)
}

SelectValueSpec <- "VALUE"i ws column:SelectItem {
    selectItem := column.(parsers.SelectItem)
	selectItem.IsTopLevel = true
    return makeColumnList(selectItem, make([]interface{}, 0))
}

TableName <- key:Identifier {
    return parsers.Table{Value: key.(string)}, nil
}

SelectArray <- "[" ws columns:ColumnList ws "]" {
    return makeSelectArray(columns)
}

SelectObject <- "{" ws field:SelectObjectField ws other_fields:(ws "," ws coll:SelectObjectField {return coll, nil })* ws "}" {
    return makeSelectObject(field, other_fields)
}

SelectObjectField <- name:(Identifier / "\"" key:Identifier "\"" { return key, nil }) ws ":" ws selectItem:SelectItem {
    item := selectItem.(parsers.SelectItem)
	item.Alias = name.(string)
	return item, nil
}

SelectProperty <- name:Identifier path:(DotFieldAccess / ArrayFieldAccess)* {
    return makeSelectItem(name, path, parsers.SelectItemTypeField)
}

SelectItem <- selectItem:(Literal / FunctionCall / SelectArray / SelectObject / SelectProperty) asClause:AsClause? {
    var itemResult parsers.SelectItem
    switch typedValue := selectItem.(type) {
    case parsers.SelectItem:
        itemResult = typedValue
    case parsers.Constant:
        itemResult = parsers.SelectItem{
            Type: parsers.SelectItemTypeConstant,
            Value: typedValue,
        }
    case parsers.FunctionCall:
        itemResult = parsers.SelectItem{
            Type: parsers.SelectItemTypeFunctionCall,
            Value: typedValue,
        }
    }

	if aliasValue, ok := asClause.(string); ok {
		itemResult.Alias = aliasValue
	}

	return itemResult, nil
}

AsClause <- ws As ws alias:Identifier { return alias, nil }

DotFieldAccess <- "." id:Identifier {
    return id, nil
}

ArrayFieldAccess <- "[\"" id:Identifier "\"]" {
    return id, nil
}

Identifier <- [a-zA-Z_][a-zA-Z0-9_]* {
    return string(c.text), nil
}

Condition <- expression:OrExpression {
    return expression, nil
}

OrExpression <- ex1:AndExpression ex2:(ws Or ws ex:AndExpression { return ex, nil })* {
    return combineExpressions(ex1, ex2, parsers.LogicalExpressionTypeOr)
}

AndExpression <- ex1:ComparisonExpression ex2:(ws And ws ex:ComparisonExpression { return ex, nil })* {
    return combineExpressions(ex1, ex2, parsers.LogicalExpressionTypeAnd)
}

ComparisonExpression <- "(" ws ex:OrExpression ws ")" { return ex, nil }
    / left:SelectItem ws op:ComparisonOperator ws right:SelectItem {
    return parsers.ComparisonExpression{Left:left,Right:right,Operation:op.(string)}, nil
} / ex:BooleanLiteral { return ex, nil }
  / ex:SelectItem { return ex, nil }

OrderByClause <- OrderBy ws ex1:OrderExpression others:(ws "," ws ex:OrderExpression { return ex, nil })* {
    return makeOrderByClause(ex1, others)
}

OrderExpression <- field:SelectProperty ws order:OrderDirection? {
    return makeOrderExpression(field, order)
}

OrderDirection <- ("ASC"i / "DESC"i) {
    if strings.EqualFold(string(c.text), "DESC") {
		return parsers.OrderDirectionDesc, nil
    }

	return parsers.OrderDirectionAsc, nil
}

Select <- "SELECT"i

Top <- "TOP"i

As <- "AS"i

From <- "FROM"i

Where <- "WHERE"i

And <- "AND"i

Or <- "OR"i

OrderBy <- "ORDER"i ws "BY"i

ComparisonOperator <- ("=" / "!=" / "<" / "<=" / ">" / ">=") {
    return string(c.text), nil
}

StringEquals <- "STRINGEQUALS"i

Literal <- FloatLiteral / IntegerLiteral / StringLiteral / BooleanLiteral / ParameterConstant / NullConstant

ParameterConstant <- "@" Identifier {
    return parsers.Constant{Type: parsers.ConstantTypeParameterConstant, Value: string(c.text)}, nil
}
NullConstant <- "null" {
    return parsers.Constant{Value: nil}, nil
}

IntegerLiteral <- number:Integer {
    return parsers.Constant{Type: parsers.ConstantTypeInteger, Value: number.(int)}, nil
}
StringLiteral <- "\"" chars:StringCharacter* "\"" {
    return parsers.Constant{Type: parsers.ConstantTypeString,Value: joinStrings(chars.([]interface{}))}, nil
}
FloatLiteral <- [0-9]+"."[0-9]+ {
    floatValue, _ := strconv.ParseFloat(string(c.text), 64)
    return parsers.Constant{Type: parsers.ConstantTypeFloat, Value: floatValue}, nil
}
BooleanLiteral <- ("true"i / "false"i) {
    boolValue, _ := strconv.ParseBool(string(c.text))
    return parsers.Constant{Type: parsers.ConstantTypeBoolean, Value: boolValue}, nil
}

FunctionCall <- StringFunctions / IsDefined

StringFunctions <- StringEqualsExpression
    / ToStringExpression
    / ConcatExpression
    / ThreeArgumentStringFunctionExpression

StringEqualsExpression <- StringEquals ws "(" ws ex1:SelectItem ws "," ws ex2:SelectItem ws ignoreCase:("," ws boolean:SelectItem { return boolean, nil })? ")" {
    return parsers.FunctionCall{Type: parsers.FunctionCallStringEquals, Arguments: []interface{}{ex1, ex2, ignoreCase}}, nil
}

ToStringExpression <- "TOSTRING"i ws "(" ws ex:SelectItem ws ")" {
    return parsers.FunctionCall{Type: parsers.FunctionCallToString, Arguments: []interface{}{ex}}, nil
}

ConcatExpression <- "CONCAT"i ws "(" ws ex1:SelectItem others:(ws "," ws ex:SelectItem { return ex, nil })+ ws ")" {
    arguments := append([]interface{}{ex1}, others.([]interface{})...)
    return parsers.FunctionCall{Type: parsers.FunctionCallConcat, Arguments: arguments}, nil
}

ThreeArgumentStringFunctionExpression <- function:ThreeArgumentStringFunction ws "(" ws ex1:SelectItem ws "," ws ex2:SelectItem ws ignoreCase:("," ws boolean:SelectItem { return boolean, nil })? ")" {
    var functionType parsers.FunctionCallType

    lowerFunction := strings.ToUpper(function.(string))
    switch lowerFunction {
    case "CONTAINS":
        functionType = parsers.FunctionCallContains
    case "ENDSWITH":
        functionType = parsers.FunctionCallEndsWith
    case "STARTSWITH":
        functionType = parsers.FunctionCallStartsWith
    case "INDEX_OF":
        functionType = parsers.FunctionCallIndexOf
    }

    return parsers.FunctionCall{Type: functionType, Arguments: []interface{}{ex1, ex2, ignoreCase}}, nil
}

ThreeArgumentStringFunction <- ("CONTAINS"i / "ENDSWITH"i / "STARTSWITH"i / "INDEX_OF"i) {
    return string(c.text), nil
}

IsDefined <- "IS_DEFINED"i ws "(" ws ex:SelectItem ws ")" {
    return parsers.FunctionCall{Type: parsers.FunctionCallIsDefined, Arguments: []interface{}{ex}}, nil
}

Integer <- [0-9]+ {
    return strconv.Atoi(string(c.text))
}

StringCharacter <- !('"' / "\\") . { return string(c.text), nil }
  / "\\" seq:EscapeSequenceCharacter { return seq, nil }

EscapeSequenceCharacter <- char:EscapeCharacter

EscapeCharacter <- "'"
  / '"'
  / "\\"
  / "b" { return "\b", nil }
  / "f" { return "\f", nil }
  / "n" { return "\n", nil }
  / "r" { return "\r", nil }
  / "t" { return "\t", nil }

non_escape_character <- !(escape_character) char:.
     { return string(c.text), nil }

ws <- [ \t\n\r]*

EOF <- !.
